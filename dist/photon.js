/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/photon.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/js/photon.js":
/*!**************************!*\
  !*** ./src/js/photon.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _waves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./waves.js */ \"./src/js/waves.js\");\n/* harmony import */ var _waves_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_waves_js__WEBPACK_IMPORTED_MODULE_0__);\n\nvar Photon = {\n  // Store an instance of the active dialog\n  activeDialog: undefined,\n  // Generates a UUID in XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n  guid: function guid() {\n    // Generate a random 4 digit number in hex XXXX\n    var s4 = function s4() {\n      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    };\n\n    return \"\".concat(s4()).concat(s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4(), \"-\").concat(s4()).concat(s4()).concat(s4());\n  },\n  // Binds event listeners where needed\n  reload: function reload() {\n    // Attach waves effect to elements that have not had it attached yet\n    _waves_js__WEBPACK_IMPORTED_MODULE_0___default.a.attach($(\".waves-effect\").not(\"[photon-tag]\")); // Waves ink\n\n    $(\".waves-ink\").not(\"[photon-tag]\").on(\"mousedown\", function (event) {\n      // Stop event spread\n      event.stopPropagation(); // Hide existing waves\n\n      _waves_js__WEBPACK_IMPORTED_MODULE_0___default.a.calm(this); // Create a new wave\n\n      _waves_js__WEBPACK_IMPORTED_MODULE_0___default.a.ripple(this, {\n        wait: 1e10\n      });\n    }).on(\"mouseup mouseleave\", function () {\n      // Hide existing waves\n      _waves_js__WEBPACK_IMPORTED_MODULE_0___default.a.calm(this);\n    }).on(\"touchstart\", function (event) {\n      // Stop event spread\n      event.stopPropagation();\n    }); // Flag changed elements as processed\n\n    $(\".waves-effect .waves-ink\").not(\"[photon-tag]\").attr(\"photon-tag\", \"\");\n  }\n}; // Initialize Waves.js\n\n_waves_js__WEBPACK_IMPORTED_MODULE_0___default.a.init(); // Bind required event listeners when the DOM loads\n\n$(Photon.reload); // Load Photon into the window scope\n\nglobal.Photon = Photon; // Export Photon as a module\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Photon);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/js/photon.js?");

/***/ }),

/***/ "./src/js/waves.js":
/*!*************************!*\
  !*** ./src/js/waves.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\r\n * Waves v0.7.6\r\n * http://fian.my.id/Waves\r\n *\r\n * Copyright 2014-2018 Alfiana E. Sibuea and other contributors\r\n * Released under the MIT license\r\n * https://github.com/fians/Waves/blob/master/LICENSE\r\n */\n;\n\n(function (window, factory) {\n  'use strict'; // AMD. Register as an anonymous module.  Wrap in function so we have access\n  // to root via `this`.\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      window.Waves = factory.call(window);\n      return window.Waves;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } // Node. Does not work with strict CommonJS, but only CommonJS-like\n  // environments that support module.exports, like Node.\n  else {}\n})((typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) === 'object' ? global : this, function () {\n  'use strict';\n\n  var Waves = Waves || {};\n  var $$ = document.querySelectorAll.bind(document);\n  var toString = Object.prototype.toString;\n  var isTouchAvailable = 'ontouchstart' in window; // Find exact position of element\n\n  function isWindow(obj) {\n    return obj !== null && obj === obj.window;\n  }\n\n  function getWindow(elem) {\n    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n  }\n\n  function isObject(value) {\n    var type = _typeof(value);\n\n    return type === 'function' || type === 'object' && !!value;\n  }\n\n  function isDOMNode(obj) {\n    return isObject(obj) && obj.nodeType > 0;\n  }\n\n  function getWavesElements(nodes) {\n    var stringRepr = toString.call(nodes);\n\n    if (stringRepr === '[object String]') {\n      return $$(nodes);\n    } else if (isObject(nodes) && /^\\[object (Array|HTMLCollection|NodeList|Object)\\]$/.test(stringRepr) && nodes.hasOwnProperty('length')) {\n      return nodes;\n    } else if (isDOMNode(nodes)) {\n      return [nodes];\n    }\n\n    return [];\n  }\n\n  function offset(elem) {\n    var docElem,\n        win,\n        box = {\n      top: 0,\n      left: 0\n    },\n        doc = elem && elem.ownerDocument;\n    docElem = doc.documentElement;\n\n    if (_typeof(elem.getBoundingClientRect) !== ( true ? \"undefined\" : undefined)) {\n      box = elem.getBoundingClientRect();\n    }\n\n    win = getWindow(doc);\n    return {\n      top: box.top + win.pageYOffset - docElem.clientTop,\n      left: box.left + win.pageXOffset - docElem.clientLeft\n    };\n  }\n\n  function convertStyle(styleObj) {\n    var style = '';\n\n    for (var prop in styleObj) {\n      if (styleObj.hasOwnProperty(prop)) {\n        style += prop + ':' + styleObj[prop] + ';';\n      }\n    }\n\n    return style;\n  }\n\n  var Effect = {\n    // Effect duration\n    duration: 750,\n    // Effect delay (check for scroll before showing effect)\n    delay: 50,\n    show: function show(e, element, velocity) {\n      // Disable right click\n      if (e.button === 2) {\n        return false;\n      }\n\n      element = element || this; // Create ripple\n\n      var ripple = document.createElement('div');\n      ripple.className = 'waves-ripple waves-rippling';\n      element.appendChild(ripple); // Get click coordinate and element width\n\n      var pos = offset(element);\n      var relativeY = 0;\n      var relativeX = 0; // Support for touch devices\n\n      if ('touches' in e && e.touches.length) {\n        relativeY = e.touches[0].pageY - pos.top;\n        relativeX = e.touches[0].pageX - pos.left;\n      } //Normal case\n      else {\n          relativeY = e.pageY - pos.top;\n          relativeX = e.pageX - pos.left;\n        } // Support for synthetic events\n\n\n      relativeX = relativeX >= 0 ? relativeX : 0;\n      relativeY = relativeY >= 0 ? relativeY : 0;\n\n      var scale = function () {\n        var a = $(element);\n        var h = element.clientHeight;\n        var w = element.clientWidth;\n        var x = relativeX;\n        var y = relativeY;\n        if (x > w / 2) x = w - x;\n        if (y > h / 2) y = h - y;\n        x = w - x;\n        y = h / 2 - y;\n        var f = (x * 1.019 + y * 0.350 + (h + w) / 2 * 0.118) / 52;\n        if (h == w) return (w - Math.abs(w - (h - (w - x) - (h - y)) - w)) / 50;\n        if (a.hasClass(\"waves-ink\")) return 0.475;\n\n        if (a.hasClass(\"waves-touch\")) {\n          a.removeClass(\"waves-touch\");\n          return f / 1.1;\n        }\n\n        return f;\n      }();\n\n      scale = \"scale(\".concat(scale, \")\");\n      var translate = 'translate(0,0)';\n\n      if (velocity) {\n        translate = 'translate(' + velocity.x + 'px, ' + velocity.y + 'px)';\n      } // Attach data to element\n\n\n      ripple.setAttribute('data-hold', Date.now());\n      ripple.setAttribute('data-x', relativeX);\n      ripple.setAttribute('data-y', relativeY);\n      ripple.setAttribute('data-scale', scale);\n      ripple.setAttribute('data-translate', translate); // Set ripple position\n\n      var rippleStyle = {\n        top: relativeY + 'px',\n        left: relativeX + 'px'\n      };\n      ripple.classList.add('waves-notransition');\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n      ripple.classList.remove('waves-notransition'); // Scale the ripple\n\n      rippleStyle['-webkit-transform'] = scale + ' ' + translate;\n      rippleStyle['-moz-transform'] = scale + ' ' + translate;\n      rippleStyle['-ms-transform'] = scale + ' ' + translate;\n      rippleStyle['-o-transform'] = scale + ' ' + translate;\n      rippleStyle.transform = scale + ' ' + translate;\n      rippleStyle.opacity = '1';\n      var duration = e.type === 'mousemove' ? 2500 : Effect.duration;\n      rippleStyle['-webkit-transition-duration'] = duration + 'ms';\n      rippleStyle['-moz-transition-duration'] = duration + 'ms';\n      rippleStyle['-o-transition-duration'] = duration + 'ms';\n      rippleStyle['transition-duration'] = duration + 'ms';\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n    },\n    hide: function hide(e, element) {\n      element = element || this;\n      var ripples = element.getElementsByClassName('waves-rippling');\n\n      for (var i = 0, len = ripples.length; i < len; i++) {\n        removeRipple(e, element, ripples[i]);\n      }\n\n      if (isTouchAvailable) {\n        element.removeEventListener('touchend', Effect.hide);\n        element.removeEventListener('touchcancel', Effect.hide);\n      }\n\n      element.removeEventListener('mouseup', Effect.hide);\n      element.removeEventListener('mouseleave', Effect.hide);\n    }\n  };\n  /**\r\n   * Collection of wrapper for HTML element that only have single tag\r\n   * like <input> and <img>\r\n   */\n\n  var TagWrapper = {\n    // Wrap <input> tag so it can perform the effect\n    input: function input(element) {\n      var parent = element.parentNode; // If input already have parent just pass through\n\n      if (parent.tagName.toLowerCase() === 'i' && parent.classList.contains('waves-effect')) {\n        return;\n      } // Put element class and style to the specified parent\n\n\n      var wrapper = document.createElement('i');\n      wrapper.className = element.className + ' waves-input-wrapper';\n      element.className = 'waves-button-input'; // Put element as child\n\n      parent.replaceChild(wrapper, element);\n      wrapper.appendChild(element); // Apply element color and background color to wrapper\n\n      var elementStyle = window.getComputedStyle(element, null);\n      var color = elementStyle.color;\n      var backgroundColor = elementStyle.backgroundColor;\n      wrapper.setAttribute('style', 'color:' + color + ';background:' + backgroundColor);\n      element.setAttribute('style', 'background-color:rgba(0,0,0,0);');\n    },\n    // Wrap <img> tag so it can perform the effect\n    img: function img(element) {\n      var parent = element.parentNode; // If input already have parent just pass through\n\n      if (parent.tagName.toLowerCase() === 'i' && parent.classList.contains('waves-effect')) {\n        return;\n      } // Put element as child\n\n\n      var wrapper = document.createElement('i');\n      parent.replaceChild(wrapper, element);\n      wrapper.appendChild(element);\n    }\n  };\n  /**\r\n   * Hide the effect and remove the ripple. Must be\r\n   * a separate function to pass the JSLint...\r\n   */\n\n  function removeRipple(e, el, ripple) {\n    // Check if the ripple still exist\n    if (!ripple) {\n      return;\n    }\n\n    ripple.classList.remove('waves-rippling');\n    var relativeX = ripple.getAttribute('data-x');\n    var relativeY = ripple.getAttribute('data-y');\n    var scale = ripple.getAttribute('data-scale');\n    var translate = ripple.getAttribute('data-translate'); // Get delay beetween mousedown and mouse leave\n\n    var diff = Date.now() - Number(ripple.getAttribute('data-hold'));\n    var delay = 350 - diff;\n\n    if (delay < 0) {\n      delay = 0;\n    }\n\n    if (e.type === 'mousemove') {\n      delay = 150;\n    } // Fade out ripple after delay\n\n\n    var duration = e.type === 'mousemove' ? 2500 : Effect.duration;\n    setTimeout(function () {\n      var style = {\n        top: relativeY + 'px',\n        left: relativeX + 'px',\n        opacity: '0',\n        // Duration\n        '-webkit-transition-duration': duration + 'ms',\n        '-moz-transition-duration': duration + 'ms',\n        '-o-transition-duration': duration + 'ms',\n        'transition-duration': duration + 'ms',\n        '-webkit-transform': scale + ' ' + translate,\n        '-moz-transform': scale + ' ' + translate,\n        '-ms-transform': scale + ' ' + translate,\n        '-o-transform': scale + ' ' + translate,\n        'transform': scale + ' ' + translate\n      };\n      ripple.setAttribute('style', convertStyle(style));\n      setTimeout(function () {\n        try {\n          el.removeChild(ripple);\n        } catch (e) {\n          return false;\n        }\n      }, duration);\n    }, delay);\n  }\n  /**\r\n   * Disable mousedown event for 500ms during and after touch\r\n   */\n\n\n  var TouchHandler = {\n    /* uses an integer rather than bool so there's no issues with\r\n     * needing to clear timeouts if another touch event occurred\r\n     * within the 500ms. Cannot mouseup between touchstart and\r\n     * touchend, nor in the 500ms after touchend. */\n    touches: 0,\n    allowEvent: function allowEvent(e) {\n      var allow = true;\n\n      if (/^(mousedown|mousemove)$/.test(e.type) && TouchHandler.touches) {\n        allow = false;\n      }\n\n      return allow;\n    },\n    registerEvent: function registerEvent(e) {\n      var eType = e.type;\n\n      if (eType === 'touchstart') {\n        TouchHandler.touches += 1; // push\n      } else if (/^(touchend|touchcancel)$/.test(eType)) {\n        setTimeout(function () {\n          if (TouchHandler.touches) {\n            TouchHandler.touches -= 1; // pop after 500ms\n          }\n        }, 500);\n      }\n    }\n  };\n  /**\r\n   * Delegated click handler for .waves-effect element.\r\n   * returns null when .waves-effect element not in \"click tree\"\r\n   */\n\n  function getWavesEffectElement(e) {\n    if (TouchHandler.allowEvent(e) === false) {\n      return null;\n    }\n\n    var element = null;\n    var target = e.target || e.srcElement;\n\n    while (target.parentElement) {\n      if (!(target instanceof SVGElement) && target.classList.contains('waves-effect')) {\n        element = target;\n        break;\n      }\n\n      target = target.parentElement;\n    }\n\n    return element;\n  }\n  /**\r\n   * Bubble the click and show effect if .waves-effect elem was found\r\n   */\n\n\n  function showEffect(e) {\n    // Disable effect if element has \"disabled\" property on it\n    // In some cases, the event is not triggered by the current element\n    // if (e.target.getAttribute('disabled') !== null) {\n    //     return;\n    // }\n    var element = getWavesEffectElement(e);\n\n    if (element !== null) {\n      // Make it sure the element has either disabled property, disabled attribute or 'disabled' class\n      if (element.disabled || element.getAttribute('disabled') || element.classList.contains('disabled')) {\n        return;\n      }\n\n      TouchHandler.registerEvent(e);\n\n      if (e.type === 'touchstart' && Effect.delay) {\n        var hidden = false;\n        var timer = setTimeout(function () {\n          timer = null;\n          Effect.show(e, element);\n        }, Effect.delay);\n\n        var hideEffect = function hideEffect(hideEvent) {\n          // if touch hasn't moved, and effect not yet started: start effect now\n          if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            Effect.show(e, element);\n          }\n\n          if (!hidden) {\n            hidden = true;\n            Effect.hide(hideEvent, element);\n          }\n\n          removeListeners();\n        };\n\n        var touchMove = function touchMove(moveEvent) {\n          if (timer) {\n            clearTimeout(timer);\n            timer = null;\n          }\n\n          hideEffect(moveEvent);\n          removeListeners();\n        };\n\n        element.addEventListener('touchmove', touchMove, false);\n        element.addEventListener('touchend', hideEffect, false);\n        element.addEventListener('touchcancel', hideEffect, false);\n\n        var removeListeners = function removeListeners() {\n          element.removeEventListener('touchmove', touchMove);\n          element.removeEventListener('touchend', hideEffect);\n          element.removeEventListener('touchcancel', hideEffect);\n        };\n      } else {\n        Effect.show(e, element);\n\n        if (isTouchAvailable) {\n          element.addEventListener('touchend', Effect.hide, false);\n          element.addEventListener('touchcancel', Effect.hide, false);\n        }\n\n        element.addEventListener('mouseup', Effect.hide, false);\n        element.addEventListener('mouseleave', Effect.hide, false);\n      }\n    }\n  }\n\n  Waves.init = function (options) {\n    var body = document.body;\n    options = options || {};\n\n    if ('duration' in options) {\n      Effect.duration = options.duration;\n    }\n\n    if ('delay' in options) {\n      Effect.delay = options.delay;\n    }\n\n    if (isTouchAvailable) {\n      body.addEventListener('touchstart', showEffect, false);\n      body.addEventListener('touchcancel', TouchHandler.registerEvent, false);\n      body.addEventListener('touchend', TouchHandler.registerEvent, false);\n    }\n\n    body.addEventListener('mousedown', showEffect, false);\n  };\n  /**\r\n   * Attach Waves to dynamically loaded inputs, or add .waves-effect and other\r\n   * waves classes to a set of elements. Set drag to true if the ripple mouseover\r\n   * or skimming effect should be applied to the elements.\r\n   */\n\n\n  Waves.attach = function (elements, classes) {\n    elements = getWavesElements(elements);\n\n    if (toString.call(classes) === '[object Array]') {\n      classes = classes.join(' ');\n    }\n\n    classes = classes ? ' ' + classes : '';\n    var element, tagName;\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n      element = elements[i];\n      tagName = element.tagName.toLowerCase();\n\n      if (['input', 'img'].indexOf(tagName) !== -1) {\n        TagWrapper[tagName](element);\n        element = element.parentElement;\n      }\n\n      if (element.className.indexOf('waves-effect') === -1) {\n        element.className += ' waves-effect' + classes;\n      }\n    }\n  };\n  /**\r\n   * Cause a ripple to appear in an element via code.\r\n   */\n\n\n  Waves.ripple = function (elements, options) {\n    elements = getWavesElements(elements);\n    var elementsLen = elements.length;\n    options = options || {};\n    options.wait = options.wait || 0;\n    options.position = options.position || null; // default = centre of element\n\n    if (elementsLen) {\n      var element,\n          pos,\n          off,\n          centre = {},\n          i = 0;\n      var mousedown = {\n        type: 'mousedown',\n        button: 1\n      };\n\n      var hideRipple = function hideRipple(mouseup, element) {\n        return function () {\n          Effect.hide(mouseup, element);\n        };\n      };\n\n      for (; i < elementsLen; i++) {\n        element = elements[i];\n        pos = options.position || {\n          x: element.clientWidth / 2,\n          y: element.clientHeight / 2\n        };\n        off = offset(element);\n        centre.x = off.left + pos.x;\n        centre.y = off.top + pos.y;\n        mousedown.pageX = centre.x;\n        mousedown.pageY = centre.y;\n        Effect.show(mousedown, element);\n\n        if (options.wait >= 0 && options.wait !== null) {\n          var mouseup = {\n            type: 'mouseup',\n            button: 1\n          };\n          setTimeout(hideRipple(mouseup, element), options.wait);\n        }\n      }\n    }\n  };\n  /**\r\n   * Remove all ripples from an element.\r\n   */\n\n\n  Waves.calm = function (elements) {\n    elements = getWavesElements(elements);\n    var mouseup = {\n      type: 'mouseup',\n      button: 1\n    };\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n      Effect.hide(mouseup, elements[i]);\n    }\n  };\n\n  return Waves;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/js/waves.js?");

/***/ })

/******/ });